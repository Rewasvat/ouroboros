
#ifndef OPWIG_GEN_WRAPPERSPECIFICATION_H_
#define OPWIG_GEN_WRAPPERSPECIFICATION_H_

#include <opwig/md/ptr.h>
#include <string>
#include <list>

namespace opwig {

namespace md {
class Function;
class Variable;
class Class;
class Namespace;
class Enum;
}

namespace gen {

/// Auxiliary struct representing a generated script module.
/** Struct representing a script module generated by the wrapper specification.
    Used to bootstrap the generated modules with the ScriptManager. */
struct ScriptModule {
    /// Name of the module.
    std::string module_name;
    /// Name of the initialization function for the module.
    std::string init_func_name;

    /// Builds a new, 'empty' script module.
    ScriptModule() : module_name(""), init_func_name("") {}
    /// Builds a new script module with given name and init function.
    ScriptModule(const std::string& modname, const std::string& initfuncname) : 
        module_name(modname), init_func_name(initfuncname) {}
};

/// Abstract class for specification of a wrapper generator.
/** Base abstract class for specification of a wrapper generator for a given
    language.
    
    This class defines a interface used by the opwig::gen::WrapperGenerator to generate
    text. The text should be valid C++ code, used to wrap a C++ API to a
    particular scripting language. */
class WrapperSpecification {

  public:
    /// constructor
    WrapperSpecification() {}
    
    /// Virtual destructor.
    virtual ~WrapperSpecification() {}
    
    /// Name of this wrapper specification (name of the language it wraps).
    /** Name of this wrapper specification (name of the language it wraps).
    * @return name of the specification.
    */
    virtual std::string wrapper_name() const = 0;
    
    /// Gets the header (initial) block of text of the generated source files.
    /** Returns the header block of text of the generated source files.
        This text block is written FIRST in the generated files, and as such
        you should put anything you will otherwise need here...
    * @return The header code block.
    */
    virtual std::string FileHeader() const = 0;

    /// Gets the 'middle' block of text code of generated source files.
    /** Returns the 'middle' code block, which is situated after the 
        input file(s) include(s) (added by the WrapperGenerator) but right
        before any metadata wrap function call. 
    * @return The middle code block.
    */
    virtual std::string MiddleBlock() const = 0;
    
    /// Gets the final block of text of the generated source files.
    /** Returns the final block of text of the generated source files.
        This text block is written LAST in the generated files, and as such
        you should put anything to finish the wrap code here...
        Most scripting languages (Python, Lua, etc) wrapping module code 
        have a 'init' function, defined last in the code, which initializes
        the module. You should write that here as well. 
    * @return The final code block.
    */
    virtual std::string FinishFile() const = 0;
    
    /// Wraps a function.
    /** Wraps a function (from its metadata), performing anything necessary to do so,
        and returns the code block pertaining to this function wrap that should be
        written to the generated file.
    * @param obj Smart pointer to a Function metadata.
    * @return The function wrap code block.
    */
    virtual std::string WrapFunction(const md::Ptr<const md::Function>& obj) = 0;
    /// Wraps a variable.
    /** Wraps a variable (from its metadata), performing anything necessary to do so,
        and returns the code block pertaining to this variable wrap that should be
        written to the generated file.
    * @param obj Smart pointer to a Variable metadata.
    * @return The variable wrap code block.
    */
    virtual std::string WrapVariable(const md::Ptr<const md::Variable>& obj) = 0;
    /// Wraps a enumeration.
    /** Wraps a enumeration (from its metadata), performing anything necessary to do so,
        and returns the code block pertaining to this function wrap that should be
        written to the generated file.
    * @param obj Smart pointer to a Enum metadata.
    * @return The enumeration wrap code block.
    */
    virtual std::string WrapEnum(const md::Ptr<const md::Enum>& obj) = 0;

    /// Wraps the start of a class.
    /** This function is called when the opwig::gen::WrapperGenerator starts
        to wrap a opwig::md::Class. If you should generate any code because of this,
        before wrapping the class' members, this function should return that code block.

        Since Classes are scopes, opwig::gen::WrapperGenerator will call these
        Open/Close methods appropriately, and between them call the regular Wrap*
        methods for the class' members.
    * @param obj Smart pointer to a Class metadata.
    * @return The class wrap code block, written before any class members.
    */
    virtual std::string OpenClass(const md::Ptr<const md::Class>& obj) = 0;
    /// Wraps the finish of a class.
    /** This function is called when the opwig::gen::WrapperGenerator finishes
        to wrap a opwig::md::Class. If you should generate any code because of this,
        after wrapping the class' members, this function should return that code block.

        Since Classes are scopes, opwig::gen::WrapperGenerator will call these
        Open/Close methods appropriately, and between them call the regular Wrap*
        methods for the class' members.
    * @param obj Smart pointer to a Class metadata.
    * @return The class wrap code block, written after any class members.
    */
    virtual std::string CloseClass(const md::Ptr<const md::Class>& obj) = 0;
    /// Wraps the start of a namespace.
    /** This function is called when the opwig::gen::WrapperGenerator starts
        to wrap a opwig::md::Namespace. If you should generate any code because of this,
        before wrapping the namespace members, this function should return that code block.

        Since Namespaces are scopes, opwig::gen::WrapperGenerator will call these
        Open/Close methods appropriately, and between them call the regular Wrap*
        methods for the namespace members.
    * @param obj Smart pointer to a Namespace metadata.
    * @return The namespace wrap code block, written before any namespace members.
    */
    virtual std::string OpenNamespace(const md::Ptr<const md::Namespace>& obj) = 0;
    /// Wraps the finish of a namespace.
    /** This function is called when the opwig::gen::WrapperGenerator finishes
        to wrap a opwig::md::Namespace. If you should generate any code because of this,
        after wrapping the namespace members, this function should return that code block.

        Since Namespace are scopes, opwig::gen::WrapperGenerator will call these
        Open/Close methods appropriately, and between them call the regular Wrap*
        methods for the namespace members.
    * @param obj Smart pointer to a Namespace metadata.
    * @return The namespace wrap code block, written after any namespace members.
    */
    virtual std::string CloseNamespace(const md::Ptr<const md::Namespace>& obj) = 0;
    
    /// Returns the signature of the load_func (initializing function) of the module.
    /** Gets the signature of the initialization function for the generated module.
    * @return String containing the signature for the initialization function.
    virtual std::string LoadFuncSignature() const = 0;

    /// Returns a list of the script modules the wrapper generated.
    /** Returns a list of the script modules generated. The opwig::gen::WrapperGenerator,
        for a given input, will only generate a single C++ code file. However, the
        file itself can define several modules for the scripting language - usually used to
        separate the namespace of the wrapper C++ API. This function returns a list 
        of these generated modules.
    * @return List of generated script modules.
    */
    virtual std::list<ScriptModule> GetGeneratedModules() const = 0;
    
    /// Gets the name of the module currently being wrapped.
    /** Gets the name of the module currently being wrapped.
    * @return Name of the module, as received by OPWIG.
    */
    const std::string& module_name() const { return module_name_; }
    
    /// Sets the name of the module currently being wrapped.
    void set_module_name(const std::string& name) { module_name_ = name; }
    
    
  protected:
    std::string module_name_;
};

} // namespace gen
} // namespace opwig

#endif // OPWIG_GEN_WRAPPERSPECIFICATION_H_


