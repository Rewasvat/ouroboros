
#ifndef OPWIG_GEN_WRAPPERSPECIFICATION_H_
#define OPWIG_GEN_WRAPPERSPECIFICATION_H_

#include <opwig/md/ptr.h>
#include <string>
#include <list>

namespace opwig {

namespace md {
class Function;
class Variable;
class Class;
class Namespace;
class Enum;
}

namespace gen {

/** Struct representing a script module generated by the wrapper specification.
    Used to bootstrap the generated modules with the ScriptManager. */
struct ScriptModule {
    std::string module_name;
    std::string init_func_name;

    ScriptModule() : module_name(""), init_func_name("") {}
    ScriptModule(const std::string& modname, const std::string& initfuncname) : 
        module_name(modname), init_func_name(initfuncname) {}
};

/** Base class for specification of a scripting language for wrapper generation.
Conversion of types between C++ and this script is provided by a <>Converter class
in OPA. */
class WrapperSpecification {

  public:
    /// constructor
    /** @param module_name The generated module's name.
     **/
    WrapperSpecification(const std::string& module_name) : module_name_(module_name) {}
    
    /// Virtual destructor.
    virtual ~WrapperSpecification() {}
    
    /// Name of this wrapper specification (name of the language it wraps).
    virtual std::string wrapper_name() const = 0;
    
    /** Returns the header block of text of the generated source files.
        This text block is written FIRST in the generated files, and as such
        you should put anything you will otherwise need here... */
    virtual std::string FileHeader() const = 0;

    /** Returns the 'middle' code block, which is situated after the 
        input file(s) include(s) but right before any metadata wrap
        function call. */
    virtual std::string MiddleBlock() const = 0;
    
    /** Returns the final block of text of the generated source files.
        This text block is written LAST in the generated files, and as such
        you should put anything to finish the wrap code here...
        Most scripting languages (Python, Lua, etc) wrapping module code 
        have a 'init' function, defined last in the code, which initializes
        the module. You should write that here as well. */
    virtual std::string FinishFile() const = 0;
    
    /** These functions are called to wrap a specific kind of metadata. They should return whatever
        code block is required to wrap such things. */
    
    virtual std::string WrapFunction(const md::Ptr<const md::Function>& obj) = 0;
    virtual std::string WrapVariable(const md::Ptr<const md::Variable>& obj) = 0;
    virtual std::string WrapEnum(const md::Ptr<const md::Enum>& obj) = 0;

    /** These methods are called when the wrapper generator enters or leaves an inner scope (classes
        and namespaces). */

    virtual std::string OpenClass(const md::Ptr<const md::Class>& obj) = 0;
    virtual std::string CloseClass(const md::Ptr<const md::Class>& obj) = 0;
    virtual std::string OpenNamespace(const md::Ptr<const md::Namespace>& obj) = 0;
    virtual std::string CloseNamespace(const md::Ptr<const md::Namespace>& obj) = 0;
    
    /// Returns the signature of the load_func (initializing function) of the module.
    virtual std::string LoadFuncSignature() const = 0;

    /// Returns a list of the script modules the wrapper generated.
    virtual std::list<ScriptModule> GetGeneratedModules() const = 0;
    
    /// Gets the name of the module currently being wrapped.
    const std::string& module_name() const { return module_name_; }
    
    
  protected:
    std::string module_name_;
};

} // namespace gen
} // namespace opwig

#endif // OPWIG_GEN_WRAPPERSPECIFICATION_H_


