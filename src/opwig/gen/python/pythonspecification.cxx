#include <opwig/gen/python/pythonspecification.h>
#include <opwig/gen/python/wrapmodule.h>
#include <opwig/gen/python/utilities.h>
#include <opwig/md/function.h>
#include <opwig/md/variable.h>
#include <opwig/md/namespace.h>
#include <opwig/md/type.h>

#include <sstream>

namespace opwig {
namespace gen {
namespace python {

using std::string;
using md::Ptr;
using std::stringstream;
using std::endl;

PythonSpecification::PythonSpecification() {
    root_module_ = Ptr<WrapModule>(new WrapModule(""));
    current_ = root_module_;
}

// HEADER BLOCK
string PythonSpecification::FileHeader() const {
    root_module_->set_name(module_name_);
    return
        "// FILE GENERATED BY OPWIG - OUROBOROS PROJECT.\n\n"
        "#include <Python.h>\n"
        "#include <languages/python/pythonwrapper.h>\n"
        "#include <languages/python/pythonconverter.h>\n"
        "#include <opa/scriptmanager.h>\n"
        "#include <opa/module.h>\n"
        "#include <iostream>\n"
        "#include <string>\n"
        "\n"
        "using std::string;\n"
        "using std::cout;\n"
        "using std::endl;\n"
        "using opa::Module;\n"
        "using opa::python::PythonWrapper;\n"
        "using opa::python::PythonConverter;\n"
        "\n";
}

string PythonSpecification::MiddleBlock() const {
    return
        "namespace {\n\n"
        "bool NumArgsOk(PyObject* args, int num) {\n"
        "    if (static_cast<int>(PyTuple_Size(args)) != num) {\n"
        "        string msg = \"expected \"+std::to_string(num)+\" parameters, but received \"+std::to_string(PyTuple_Size(args))+\".\";\n"
        "        PyErr_SetString(PyExc_RuntimeError, msg.c_str());\n"
        "        return false;\n"
        "    }\n"
        "    return true;\n"
        "}\n"
        "} // unnamed namespace\n\n"
        "namespace "+BASE_NSPACE+" {\n\n";
}

// FINISH BLOCK
void HandleWrapModuleForInitFunc(stringstream& block, const Ptr<WrapModule>& module) {
    block << TAB << "PyObject* " << module->name() << "_mod = Py_InitModule(\"" << module->name();
    block << "\", " << module->GetMethodTableName() << ");" << endl;
    
    if (module->parent()) {
        block << TAB << "Py_INCREF(" << module->name() << "_mod);" << endl;
        block << TAB << "if (PyModule_AddObject(" << module->parent()->name() << "_mod, \"";
        block << module->name() << "\", " << module->name() << "_mod) == -1) {" << endl;
        block << TAB << TAB << "PyErr_SetString(PyExc_RuntimeError, \"could not add submodule '";
        block << module->name() << "' to module '" << module->parent()->name() << "'\");" << endl;
        block << TAB << "}" << endl;
    }

    for (auto subm : module->sub_modules() )
        HandleWrapModuleForInitFunc(block, subm);
}

void HandleModuleMethodTables(stringstream& block, const Ptr<WrapModule>& module) {
    block << "//module " << module->name() << " method table" << endl;
    block << module->GenerateMethodTable(BASE_NSPACE) << endl;
    for (auto subm : module->sub_modules() )
        HandleModuleMethodTables(block, subm);
}

void TEST(stringstream& block, const Ptr<WrapModule>& module) {
    block << "PyMODINIT_FUNC" << endl;
    block << GetInitFuncNameForModule(module->name()) << "(void) {" << endl;
    block << TAB;
    if (module->sub_modules().size() > 0)
        block << "PyObject* " << module->name() << "_mod = ";
    block << "Py_InitModule(\"" << module->full_dotted_name() << "\", " << module->GetMethodTableName() << ");" << endl;
    
    block << TAB << "cout << \"Initializing '" << module->name() << "'\" << endl;" << endl;
    for (auto subm : module->sub_modules() ) {
        block << TAB << "PyObject* "<< subm->name() <<"_mod = PyImport_AddModule(\""<< subm->full_dotted_name() << "\");" << endl;
        block << TAB << "if ("<< subm->name() <<"_mod == nullptr) {" << endl;
        block << TAB << TAB << "cout << \"Initializing '" << module->name() << "', could not import '"<< subm->name() <<"'\" << endl;" << endl;
        block << TAB << TAB << "PyErr_SetString(PyExc_RuntimeError, \"Initializing '" << module->name() << "', could not import '"<< subm->name() <<"'\");" << endl;
        //block << TAB << TAB << "return;" << endl;
        block << TAB << "}" << endl;
        
        block << TAB << "Py_INCREF(" << subm->name() << "_mod);" << endl;
        block << TAB << "if (PyModule_AddObject(" << module->name() << "_mod, \"";
        block << subm->name() << "\", " << subm->name() << "_mod) == -1) {" << endl;
        block << TAB << TAB << "PyErr_SetString(PyExc_RuntimeError, \"could not add submodule '";
        block << subm->name() << "' to module '" << module->name() << "'\");" << endl;
        block << TAB << "}" << endl;
    }

    block << "}" << endl;

    for (auto subm : module->sub_modules() )
        TEST(block, subm);
}

string PythonSpecification::FinishFile() const {
    stringstream block;
    block << endl << "} //namespace " << BASE_NSPACE << endl << endl;
    HandleModuleMethodTables(block, root_module_);
    /*block << "PyMODINIT_FUNC" << endl;
    block << GetInitFuncNameForModule(module_name_) << "(void) {" << endl;
    HandleWrapModuleForInitFunc(block, root_module_);
    block << "}" << endl;*/
    TEST(block, root_module_);
    return block.str();
}

// WRAP FUNCION
string PythonSpecification::WrapFunction(const Ptr<const md::Function>& obj) {
    current_->AddFunction(obj);
        
    stringstream func;
    func << "PyObject* " << FUNC_PREFIX << obj->name() << "(PyObject* self, PyObject* args) {" << std::endl;
    if (obj->num_parameters() > 0)
        func << TAB << "if (!NumArgsOk(args, " << obj->num_parameters() << ")) return nullptr;" << endl;
    func << TAB << "PythonConverter converter;" << std::endl;
    stringstream args ("");
    for (unsigned i=0; i<obj->num_parameters(); i++) {
        func << TAB << obj->parameter_type(i)->full_type() <<" fArg"<< i << ";" << endl;
        func << TAB << "try { fArg"<< i <<" = converter.PyArgToType<"<< obj->parameter_type(i)->full_type() <<">(args, " << i << "); }" << endl;
        func << TAB << "catch (std::exception& e) { cout << e.what() << endl; return nullptr; }" << endl;
        if (i > 0)
            args << ", ";
        args << "fArg" << i;
    }
    if (obj->return_type()->full_type() == "void") {
        func << TAB << obj->nested_name() << "("<< args.str() << ");" << endl;
        func << TAB << "Py_RETURN_NONE;" << endl;
    }
    else {
        func << TAB << obj->return_type()->full_type() << " fValue = " << obj->nested_name() << "("<< args.str() << ");" << endl;
        func << TAB << "return converter.TypeToScript<"<< obj->return_type()->full_type() <<">(fValue);" << endl;
    }
    func << "}";
    return func.str();
}

// WRAP VARIABLE
string PythonSpecification::WrapVariable(const Ptr<const md::Variable>& obj) {
    current_->AddVariable(obj);
    stringstream func;
    func << "PyObject* " << FUNC_PREFIX << obj->name() << "(PyObject* self, PyObject* args) {" << std::endl;
    func << TAB << "PythonConverter converter;" << std::endl;
    func << TAB << obj->type()->full_type() << " oldValue = " << obj->nested_name() << ";" << endl;
    if (!obj->type()->is_const()) {
        func << TAB << "if (static_cast<int>(PyTuple_Size(args)) == 1) {" << endl;
        func << TAB << TAB << obj->type()->full_type() <<" newValue;" << endl;
        func << TAB << TAB << "try { newValue = converter.PyArgToType<"<< obj->type()->full_type() <<">(args, 0); }" << endl;
        func << TAB << TAB << "catch (std::exception& e) { cout << e.what() << endl; return nullptr; }" << endl;
        func << TAB << TAB << obj->nested_name() << " = newValue;" << endl;
        func << TAB << "}" << endl;
        func << TAB << "else if (!NumArgsOk(args, 0)) return nullptr;" << endl;
    }
    func << TAB << "return converter.TypeToScript<" << obj->type()->full_type() <<">(oldValue);" << endl;
    func << "}";
    return func.str();
}

// WRAP CLASS
string PythonSpecification::WrapClass(const Ptr<const md::Class>& obj) {
    return "";
}

// WRAP NAMESPACE
string PythonSpecification::WrapNamespace(const Ptr<const md::Namespace>& obj, bool closing) {
    if (!closing) {
        Ptr<WrapModule> newm = Ptr<WrapModule>(new WrapModule(obj->name(), current_));
        current_->AddSubModule(newm);
        current_ = newm;
        return "namespace "+obj->name()+" {\n";
    }
    else {
        current_ = current_->parent();
        return "} //closing namespace "+obj->name()+"\n";
    }
}

// WRAP ENUM
string PythonSpecification::WrapEnum(const Ptr<const md::Enum>& obj) {
    return "";
}

std::list<ScriptModule> PythonSpecification::GetGeneratedModules () const {
    return root_module_->ConvertTreeToScriptModuleList();
}

} // namespace python
} // namespace gen
} // namespace opwig
