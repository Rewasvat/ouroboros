#include <opwig/gen/python/pythonspecification.h>
#include <opwig/md/function.h>

#include <sstream>

namespace opwig {
namespace gen {
namespace python {

using std::string;
using md::Ptr;
using std::stringstream;
using std::cout;
using std::endl;

const char* TAB = "    ";

// HEADER BLOCK
string PythonSpecification::FileHeader() const {
    return
        "// FILE GENERATED BY OPWIG - OUROBOROS PROJECT.\n\n"
        "#include <Python.h>\n"
        "#include <languages/python/pythonwrapper.h>\n"
        "#include <opa/scriptmanager.h>\n"
        "#include <opa/module.h>\n"
        "#include <iostream>\n"
        "#include <string>\n"
        "\n"
        "using std::string;\n"
        "using std::cout;\n"
        "using std::endl;\n"
        "using opa::Module;\n"
        "using opa::python::PythonWrapper;\n"
        "\n"
        "namespace {\n\n"
        "const char *MODULE_NAME = \""+module_name_+"\";\n\n"
        "} // unnamed namespace\n\n";
}


// FINISH BLOCK
std::string PythonSpecification::generateMethodTable() const {
    stringstream table;
    table << "static PyMethodDef ModuleMethods[] = {" << endl;
    for (auto func_name : wrapped_functions_)
        table << TAB << "{\"" << func_name << "\", OPWIG_wrap_" << func_name << ", METH_VARARGS, \"calls C++ wrapped function\" }," << endl;
    table << TAB << "{NULL, NULL, 0, NULL} //sentinel" << endl;
    table << "};" << endl;
    return table.str();
}

string PythonSpecification::FinishFile() const {
    stringstream block;
    block << generateMethodTable() << endl;
    block << "PyMODINIT_FUNC" << endl;
    block << LoadFuncName() << "(void) {" << endl;
    block << TAB << "Py_InitModule(MODULE_NAME, ModuleMethods);" << endl;
    block << "}" << endl;
    return block.str();
}

// WRAP FUNCION
string PythonSpecification::WrapFunction(const Ptr<const md::Function>& obj) {
    wrapped_functions_.push_back(obj->name());
        
    stringstream func;
    func << "PyObject* OPWIG_wrap_"+obj->name()+"(PyObject* self, PyObject* args) {" << std::endl;
    func << TAB << "PythonConverter converter ();" << std::endl;
    stringstream args ("");
    for (unsigned i=0; i<obj->num_parameters(); i++) {
        func << TAB << "try { " obj->parameter_type(i) <<" fArg"<< i <<" = converter.PyArgToType<"<< obj->parameter_type(i) <<">(args, " << i << "); }" << endl;
        func << TAB << "catch () { return nullptr; }" << endl;
        if (i > 0)
            args << ", ";
        args << "fArg" << i;
    }
    if (obj->return_type() == "void") {
        func << TAB << obj->name() << "("<< args.str() << ");" << endl;
        func << TAB << "return Py_RETURN_NONE;" << endl;
    }
    else {
        func << TAB << obj->return_type() << " fValue = " << obj->name() << "("<< args.str() << ");" << endl;
        func << TAB << "return converter.TypeToScript<"<< obj->return_type() <<">(fValue);" << endl;
    }
    func << "}";
    return func.str();
}

// WRAP VARIABLE
string PythonSpecification::WrapVariable(const Ptr<const md::Variable>& obj) {
    return "";
}

// WRAP CLASS
string PythonSpecification::WrapClass(const Ptr<const md::Class>& obj) {
    return "";
}

// WRAP NAMESPACE
string PythonSpecification::WrapNamespace(const Ptr<const md::Namespace>& obj) {
    return "";
}

// WRAP ENUM
string PythonSpecification::WrapEnum(const Ptr<const md::Enum>& obj) {
    return "";
}

} // namespace python
} // namespace gen
} // namespace opwig
