//=========================// BLOCK DECLARAIONS //

block_declaration:
    simple_declaration { $$ = $1; }
|
    opaque_enum_declaration {
        $$ = [] (md::Ptr<md::Scope> current_scope) -> bool { return true; };
        //TODO: not sure exactly... Since a opaque-enum-declaration does not define the enum values',
        // we might not even need a action for this rule (rule purely for grammar completeness)
    }
;

simple_declaration:
  ';'
|
  decl_specifier_seq init_declarator_list ';' {
    $$ = parser::JoinDeclarations($1, $2);
  }
|
  decl_specifier_seq ';' {
    $$ = parser::AddTypeToScope($1);
  }
|
  init_declarator_list ';'
;

decl_specifier_seq:
  type_specifier { $$ = $1; }
|
  decl_specifier decl_specifier_seq_opt {
    TypeAction action1 = $1, action2 = $2;
    $$ = [action1, action2] (md::Ptr<md::Scope> current_namespace) {
      parser::DeclSpecifier spec1 = action1(current_namespace), spec2 = action2(current_namespace);
      return parser::DeclSpecifier::Join(spec1, spec2);
    };
  }
;

decl_specifier_seq_opt:
  /* empty */ {
    $$ = [] (md::Ptr<md::Scope> current_namespace) { return parser::DeclSpecifier::EMPTY(); };
  }
|
  decl_specifier_seq { $$ = $1; }
;

decl_specifier:
  FRIEND {
    $$ = [] (md::Ptr<md::Scope> current_namespace) { return parser::DeclSpecifier::FRIEND(); };
  }
|
  TYPEDEF {
    $$ = [] (md::Ptr<md::Scope> current_namespace) { return parser::DeclSpecifier::TYPEDEF(); };
  }
|
  VIRTUAL {
    $$ = [] (md::Ptr<md::Scope> current_namespace) { return parser::DeclSpecifier::VIRTUAL(); };
  }
;
