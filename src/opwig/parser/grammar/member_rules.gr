//=========================// MEMBER SPECIFICATION //

member_specification:
    member_declaration {
        $$ = std::shared_ptr<ScopeActionList>(new ScopeActionList);
        ($$)->push_back($1);
    }
|
    member_declaration member_specification {
        ($2)->push_back($1);
        $$ = $2;
    }
|
    access_specifier ':' 
|
    access_specifier ':' member_specification
;

member_declaration:
    decl_specifier_seq ';' {
        TypeAction type_action = $1;
        $$ = [type_action] (md::Ptr<md::Scope> current_scope) -> bool {
            type_action(current_scope);
            return true;
        };
    }
|
    member_declarator_list ';'
|
    decl_specifier_seq member_declarator_list ';' {
        TypeAction type_action = $1;
        std::shared_ptr<parser::DeclaratorList> init_list = $2;
        $$ = [type_action, init_list] (md::Ptr<md::Scope> current_scope) -> bool {
            for (auto declarator: *init_list) {
                std::string type = type_action(current_scope);
                if (declarator.has_parameters()) {
                    md::Ptr<md::Function> func =
                        md::Function::Create(declarator.name(), type, declarator.parameters());
                    if (!current_scope->AddNestedFunction(func));
                } else {
                    md::Ptr<md::Variable> var = md::Variable::Create(declarator.name(), type);
                    if (!current_scope->AddGlobalVariable(var)) {
                        //std::cout << "Namespace action failed: could not add variable " << declarator << " (type: " << type << ")" << std::endl;
                    }
                }
            }
            return true;
        };
    }
//incomplete
;

member_declarator_list:
    member_declarator {
        $$ = std::shared_ptr<parser::DeclaratorList>(new parser::DeclaratorList);
        ($$)->push_back($1);
    }
|
    member_declarator_list ',' member_declarator {
        ($1)->push_back($3);
        $$ = $1;
    }
;

member_declarator:
    declarator { $$ = $1; }
|
    declarator pure_specifier
|
    declarator brace_or_equal_initializer
|
    ':' constant_expression
|
	identifier ':' constant_expression
;

pure_specifier:
    '=' INTEGER_LITERAL {
        if (d_scanner.matched() != "0")
            throw md::SemanticError("Errouneous pure-specifier (should be '= 0' )");
    }
;
