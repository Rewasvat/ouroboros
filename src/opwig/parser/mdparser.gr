
%class-name           MDParser
%baseclass-preinclude <opwig/parser/mdparser-preincludes.h>
%namespace            opwig
%polymorphic
  Declaration:      ScopeAction;
  DeclarationSeq:   std::shared_ptr<ScopeActionList>;
  Type:             TypeAction;
  Class:            md::Ptr<md::Class>;
  BaseSpecifier:    parser::BaseSpecifier;
  BaseSpecifierSeq: std::shared_ptr<BaseSpecifierList>;
  AccessSpecifier:  parser::AccessSpecifier;
  String:           std::string;
  StringSeq:        std::shared_ptr<StringList>;

%token IDENTIFIER
%token PRIMITIVE

// Keywords
%token CATCH
%token CLASS
%token CONST
%token ENUM
%token EXPLICIT
%token EXPORT
%token EXTERN
%token FALSE
%token FRIEND
%token INLINE
%token MUTABLE
%token NAMESPACE
%token OPERATOR
%token PRIVATE
%token PROTECTED
%token PUBLIC
%token REGISTER
%token RETURN
%token SIGNED
%token SIZEOF
%token STATIC
%token STRUCT
%token TEMPLATE
%token THROW
%token TRUE
%token TRY
%token TYPEDEF
%token TYPEID
%token TYPENAME
%token UNION
%token UNSIGNED
%token USING
%token VIRTUAL
%token VOID
%token VOLATILE

// Literals
%token STRING_LITERAL
%token CHARACTER_LITERAL
%token INTEGER_LITERAL
%token HEXADECIMAL_LITERAL
%token OCTAL_LITERAL
%token FLOAT_LITERAL

%type<DeclarationSeq>       declaration_seq
%type<Declaration>          declaration
%type<Declaration>          block_declaration
%type<Declaration>          simple_declaration
%type<Declaration>          namespace_definition
%type<Declaration>          named_namespace_definition
%type<Declaration>          unnamed_namespace_definition

%type<Type>                 decl_specifier_seq
%type<Type>                 type_specifier
%type<Type>                 trailing_type_specifier
%type<Type>                 simple_type_specifier
%type<Type>                 class_specifier

%type<Class>                class_head

%type<BaseSpecifierSeq>     base_clause
%type<BaseSpecifierSeq>     base_specifier_list

%type<BaseSpecifier>        base_specifier

%type<AccessSpecifier>      access_specifier

%type<String>         identifier
%type<String>         type_name
%type<String>         init_declarator
%type<String>         declarator
%type<String>         ptr_declarator
%type<String>         noptr_declarator
%type<String>         declarator_id
%type<String>         class_head_name
%type<String>         base_type_specifier
%type<String>         class_name

%type<StringSeq>     init_declarator_list

%%

//=========================// TOP-LEVEL //

input:
  declaration_seq {
    for (auto it: *$1)
      if (!(it) (global_namespace_))
        std::cout << "Namespace action failed (global)";
  }
;

declaration_seq:
  /* empty */ {
    $$ = std::shared_ptr<ScopeActionList>(new ScopeActionList);
  }
|
  declaration_seq declaration {
    ($1)->push_back($2);
    $$ = $1;
  }
;

declaration:
  block_declaration {
    $$ = $1;
  }
|
  namespace_definition { 
    $$ = $1;
  }
//|
//  function_declaration
;

//=========================// BLOCK DECLARAIONS //

block_declaration:
  simple_declaration { $$ = $1; }
;

simple_declaration:
  ';'
|
  decl_specifier_seq init_declarator_list ';' {
    TypeAction type_action = $1;
    std::shared_ptr<StringList> init_list = $2;
    $$ = [type_action, init_list] (md::Ptr<md::Scope> current_namespace) -> bool {
      for (auto it: *init_list) {
        std::string type = type_action(current_namespace);
        md::Ptr<md::Variable> var = md::Variable::Create(it, type);
        if (!current_namespace->AddGlobalVariable(var)) {
          //std::cout << "Namespace action failed: could not add variable " << it << " (type: " << type << ")" << std::endl;
        }
      }
      return true;
    };
  }
|
  decl_specifier_seq ';' {
    TypeAction type_action = $1;
    $$ = [type_action] (md::Ptr<md::Scope> current_namespace) -> bool {
        type_action(current_namespace);
        return true;
    };
  }
|
  init_declarator_list ';'
;

decl_specifier_seq:
  type_specifier { $$ = $1; }
|
  decl_specifier decl_specifier_seq { $$ = $2; }
;

decl_specifier:
  FRIEND
|
  TYPEDEF
;

//=========================// INIT DECLARATOR //

init_declarator_list:
  init_declarator {
    $$ = std::shared_ptr<StringList>(new StringList);
    ($$)->push_back($1);
  }
|
  init_declarator_list ',' init_declarator {
    ($1)->push_back($3);
    $$ = $1;
  }
;

init_declarator:
  declarator { $$ = $1; }
|
  declarator initializer { $$ = $1; }
;

declarator:
  ptr_declarator { $$ = $1; }
;

ptr_declarator:
  noptr_declarator { $$ = $1; }
|
  ptr_operator declarator { $$ = $2; }
;

noptr_declarator:
  declarator_id { $$ = $1; }
|
  noptr_declarator '[' expression ']' { $$ = $1; }
|
  '(' ptr_declarator ')' { $$ = $2; }
;

ptr_operator:
  '*'
|
  '&'
;

declarator_id:
  identifier { $$ = $1; }
;

initializer:
  brace_or_equal_initializer
;

brace_or_equal_initializer:
  '=' initializer_clause
;

initializer_clause:
  expression
;

//=========================// FUNCTION DECLARATIONS //
//
//function_declaration:
//  type_specifier identifier '(' param_list ')' ';' {
//    std::cout << "Function declaration" << std::endl;
//  }
//;
//
//param_list:
//  /* empty */
//|
//  param_spec
//|
//  param_spec ',' param_list
//;
//
//param_spec:
//  type_specifier
//|
//  type_specifier identifier
//;
//

//=========================// NAMESPACE DEFINITION //

namespace_definition:
  named_namespace_definition {
    $$ = $1;
  }
|
  unnamed_namespace_definition {
    $$ = [] (md::Ptr<md::Scope> current_namespace) -> bool { return true; };
  }
;

named_namespace_definition:
  NAMESPACE identifier '{' declaration_seq '}' {
    using md::Namespace;
    using md::Ptr;
    Ptr<Namespace> new_namespace = Namespace::Create();
    std::string name = $2;
    for (auto it: *$4)
      if (!(it) (new_namespace))
        std::cout << "Namespace action failed (new)";
    $$ = [name,new_namespace] (Ptr<md::Scope> current_namespace) -> bool {
      return current_namespace->AddNestedNamespace(name, new_namespace);
    };
  }
|
  INLINE NAMESPACE identifier '{' declaration_seq '}'
;

unnamed_namespace_definition:
  NAMESPACE '{' declaration_seq '}'
|
  INLINE NAMESPACE '{' declaration_seq '}'
;

//=========================// TYPE SPECIFICATION //

type_specifier:
  trailing_type_specifier { $$ = $1; }
|
  class_specifier { $$ = $1; }
;

trailing_type_specifier:
  simple_type_specifier { $$ = $1; }
;

simple_type_specifier:
  type_name { 
    std::string name = $1;
    $$ = [name] (md::Ptr<md::Scope> current_namespace) -> std::string {
        return name;
    }; 
  }
;

type_name:
  identifier { $$ = $1; }
;

//=========================// CLASS SPECIFICATION //

class_specifier:
  class_head '{' '}' {
    md::Ptr<md::Class> classObj = $1;
    $$ = [classObj] (md::Ptr<md::Scope> current_namespace) -> std::string {
        if (current_namespace->AddNestedClass(classObj->name(), classObj))
            return classObj->name();
        throw md::SemanticError("Non-anonymous class cannot have empty name!");
    };
  }
;

class_head:
  class_key { $$ = md::Class::Create("", BaseSpecifierList()); }
|
  class_key base_clause { $$ = md::Class::Create("", *$2); }
|
  class_key class_head_name { $$ = md::Class::Create($2, BaseSpecifierList()); }
|
  class_key class_head_name base_clause { $$ = md::Class::Create($2, *$3); }
;

class_head_name:
  class_name { $$ = $1; }
;

base_clause:
  ':' base_specifier_list { $$ = $2; }
;

base_specifier_list:
  base_specifier {
    $$ = std::shared_ptr<BaseSpecifierList>(new BaseSpecifierList);
    ($$)->push_back($1);
  }
|
  base_specifier_list ',' base_specifier {
    ($1)->push_back($3);
    $$ = $1;
  }
;

base_specifier:
  base_type_specifier { $$ = parser::BaseSpecifier($1); }
|
  VIRTUAL base_type_specifier { $$ = parser::BaseSpecifier($2, true); }
|
  access_specifier base_type_specifier { $$ = parser::BaseSpecifier($2, $1); }
|
  VIRTUAL access_specifier base_type_specifier { $$ = parser::BaseSpecifier($3, true, $2); }
|
  access_specifier VIRTUAL base_type_specifier { $$ = parser::BaseSpecifier($3, true, $1); }
;

base_type_specifier:
  class_name { $$ = $1; }
;

access_specifier:
  PRIVATE { $$ = parser::AccessSpecifier::PRIVATE; }
| 
  PROTECTED { $$ = parser::AccessSpecifier::PROTECTED; }
|
  PUBLIC { $$ = parser::AccessSpecifier::PUBLIC; }
;

class_name:
  identifier { $$ = $1; }
;

class_key:
  CLASS | UNION | STRUCT
;

//=========================// EXPRESSIONS //

expression:
  term
|
  expression term
;

term:
  literal
|
  identifier
|
  operand
|
  '(' expression ')'
;

literal:
  STRING_LITERAL
|
  CHARACTER_LITERAL
|
  INTEGER_LITERAL
|
  HEXADECIMAL_LITERAL
|
  OCTAL_LITERAL
|
  FLOAT_LITERAL
;

operand:
  '+' | '-' | '*' | '/' | '%' | '^' | '?' | ':' ;

//=========================// IDENTIFIERS //

identifier:
  IDENTIFIER {
    $$ = d_scanner.matched();
  }
;
  
//stuff:
//  IDENTIFIER { std::cout << "Identifier" << std::endl; }
//|
//  KEYWORD { std::cout << "Keyword" << std::endl; }
//|
//  STRING_LITERAL { std::cout << "String" << std::endl; }
//|
//  CHARACTER_LITERAL { std::cout << "Character" << std::endl; }
//|
//  INTEGER_LITERAL { std::cout << "Integer" << std::endl; }
//|
//  HEXADECIMAL_LITERAL { std::cout << "Hexadecimal" << std::endl; }
//|
//  OCTAL_LITERAL { std::cout << "Octal" << std::endl; }
//|
//  FLOAT_LITERAL { std::cout << "Float" << std::endl; }
//;

